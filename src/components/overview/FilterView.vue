<template>
  <div class="filter-view">
    <!-- Top compact control section -->
    <div class="control-section">
      <div class="main-controls">
        <!-- Search and display count controls -->
        <div class="search-section">
          <input 
            type="text" 
            class="search-box" 
            placeholder="Search questions..." 
            v-model="searchQuery"
            @input="handleSearch"
          />
          <button class="search-btn" @click="performSearch">
            <i class="search-icon">üîç</i>
          </button>
          <button class="confirm-btn" @click="handleAddQuestion">
            <i class="confirm-icon">‚úì</i>
          </button>
        </div>
        <div class="slider-container">
          <span class="slider-label">Display:</span>
          <input 
            type="range" 
            min="10" 
            max="100" 
            step="10" 
            class="density-slider" 
            v-model="displayCount"
            @input="updateDisplayCount"
          />
          <span class="slider-value">{{ displayCount }}</span>
        </div>
      </div>
      
      <!-- Active filter tags compact display -->
      <div class="active-filters" v-if="hasActiveFiltersOrTags">
        <div class="filter-chips">
          <div v-for="(filter, index) in activeFilters" :key="`filter-${index}`" class="filter-chip">
            <span>{{ filter.label }}:{{ filter.value }}</span>
            <button class="remove-filter" @click="removeFilter(filter.key)">√ó</button>
          </div>
          
          <!-- Custom tags display -->
          <div v-for="(tag, index) in customTags" :key="`tag-${index}`" class="tag-chip">
            <span class="tag-icon">üè∑Ô∏è</span><span>{{ tag }}</span>
            <button class="remove-tag" @click="removeTag(index)">√ó</button>
          </div>
          
          <button class="clear-all" @click="clearAllFilters">Clear</button>
        </div>
      </div>
    </div>
    
    <!-- Question preview area -->
    <div class="question-preview">
      <h3 class="section-title">Question Preview</h3>
      <div v-if="questionStore.filteredQuestions.length > 0" class="preview-list">
        <div v-for="(question, index) in previewQuestions" :key="question.id" class="preview-item"
            :class="{ 'highlighted': question.id === questionStore.currentQuestionId }"
            @click="selectQuestion(question)">
          <span class="item-id">#{{ question.id }}</span>
          <span class="item-text">{{ truncateText(question.text || question.question, 80) }}</span>
        </div>
        <div v-if="questionStore.filteredQuestions.length > previewCount" class="more-items">
          {{ questionStore.filteredQuestions.length - previewCount }} more questions...
        </div>
      </div>
      <div v-else class="empty-preview">
        No matching questions, please adjust filter conditions
      </div>
    </div>

    <!-- Inline filter section - always visible -->
    <div class="inline-filter-section">
      <div class="filter-header">
        <h3>Filter Settings</h3>
      </div>

      <!-- Filter options -->
      <div class="filter-options">
        <!-- Weight settings area -->
        <div class="weights-section">
          
          <!-- Sliders instead of button groups -->
          <div class="weights-grid">
            <div class="weight-item">
              <label class="weight-label" style="color: #e09192">Retrieval Ineffectiveness</label>
              <div class="weight-control">
                <input 
                  type="range" 
                  min="0" 
                  max="5" 
                  step="1" 
                  class="weight-slider" 
                  v-model="weights.retrieval_effectiveness"
                />
                <span class="weight-value">{{ weights.retrieval_effectiveness }}</span>
              </div>
            </div>
            
            <div class="weight-item">
              <label class="weight-label" style="color: #dbc076">Prompt Fragility</label>
              <div class="weight-control">
                <input 
                  type="range" 
                  min="0" 
                  max="5" 
                  step="1" 
                  class="weight-slider" 
                  v-model="weights.retrieval_stability"
                />
                <span class="weight-value">{{ weights.retrieval_stability }}</span>
              </div>
            </div>
            
            <div class="weight-item">
              <label class="weight-label" style="color: #c5a3d0">Standard Anomaly</label>
              <div class="weight-control">
                <input 
                  type="range" 
                  min="0" 
                  max="5" 
                  step="1" 
                  class="weight-slider" 
                  v-model="weights.knowledge_reliability"
                />
                <span class="weight-value">{{ weights.knowledge_reliability }}</span>
              </div>
            </div>
            
            <div class="weight-item">
              <label class="weight-label" style="color: #7eb0d5">Generation Anomaly</label>
              <div class="weight-control">
                <input 
                  type="range" 
                  min="0" 
                  max="5" 
                  step="1" 
                  class="weight-slider" 
                  v-model="weights.generation_reliability"
                />
                <span class="weight-value">{{ weights.generation_reliability }}</span>
              </div>
            </div>
            
            <div class="weight-item">
              <label class="weight-label" style="color: #34495E">Question Correctness</label>
              <div class="weight-control">
                <input 
                  type="range" 
                  min="0" 
                  max="5" 
                  step="1" 
                  class="weight-slider" 
                  v-model="weights.correctness"
                />
                <span class="weight-value">{{ weights.correctness }}</span>
              </div>
            </div>
            
            <div class="weight-item">
              <label class="weight-label" style="color: #34495E">Topic Relevance</label>
              <div class="weight-control">
                <input 
                  type="range" 
                  min="0" 
                  max="5" 
                  step="1" 
                  class="weight-slider" 
                  v-model="weights.relevance"
                />
                <span class="weight-value">{{ weights.relevance }}</span>
              </div>
            </div>
          </div>
        </div>
        
        <!-- <div class="tags-section">
          <h4 class="subsection-title">Tag Management</h4>
          
          <div class="tags-input-container">
            <input 
              type="text" 
              class="tag-input" 
              placeholder="Add new tag..." 
              v-model="newTag"
              @keydown.enter="addTag(newTag)"
            />
            <button class="add-tag-btn" @click="addTag(newTag)">Add</button>
          </div>
          
          <div class="tags-list">
            <div v-if="customTags.length === 0" class="no-tags">
              No custom tags yet
            </div>
            <div v-for="(tag, index) in customTags" :key="index" class="tag-item">
              <span class="tag-name">{{ tag }}</span>
              <button class="remove-tag-btn" @click="removeTag(index)">√ó</button>
            </div>
          </div>
        </div> -->

        <!-- <div class="filter-footer">
          <button class="apply-btn" @click="applyChanges">Apply</button>
        </div> -->
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, reactive, computed, onMounted, watch, nextTick } from 'vue';
import { useQuestionStore } from '../../store/questionStore';
import eventBus from '../../utils/eventBus';

const questionStore = useQuestionStore();

// ÊêúÁ¥¢ÂíåÊòæÁ§∫ËÆæÁΩÆ
const searchQuery = ref('');
const displayCount = ref(50);
const previewCount = ref(5);
const isRankedSearch = ref(false); 

// ËøáÊª§Âô®Áä∂ÊÄÅ
const filters = reactive({
  retrieval_effectiveness: { min: 0, max: 1 },
  retrieval_stability: { min: 0, max: 1 },
  generation_reliability: { min: 0, max: 1 },
  knowledge_reliability: { min: 0, max: 1 }
});

// ÊùÉÈáçËÆæÁΩÆ
const weights = reactive({
  retrieval_effectiveness: 3,
  retrieval_stability: 3,
  generation_reliability: 3,
  knowledge_reliability: 3,
  correctness: 3,
  relevance: 3
});

// Ëá™ÂÆö‰πâÊ†áÁ≠æ
const customTags = ref([]);
const newTag = ref('');

// Â§á‰ªΩÂΩìÂâçËøáÊª§Áä∂ÊÄÅ
const filtersBackup = reactive({});
const weightsBackup = reactive({});
const tagsBackup = ref([]);

onMounted(async () => {
  await questionStore.loadSummaryMetrics();
  displayCount.value = questionStore.topQuestionCount;
  Object.assign(filters, JSON.parse(JSON.stringify(questionStore.filterConditions)));
  Object.assign(filtersBackup, JSON.parse(JSON.stringify(filters)));
  Object.assign(weightsBackup, JSON.parse(JSON.stringify(weights)));
  tagsBackup.value = [...customTags.value];
});

// ÁõëÂê¨Áä∂ÊÄÅÂèòÂåñ
watch(() => questionStore.topQuestionCount, (newCount) => {
  displayCount.value = newCount;
}, { immediate: true });

watch(() => questionStore.filterConditions, (newConditions) => {
  Object.assign(filters, JSON.parse(JSON.stringify(newConditions)));
}, { deep: true });

// È¢ÑËßàÂå∫ÂüüÈóÆÈ¢òÂàóË°®
const previewQuestions = computed(() => {
  return questionStore.filteredQuestions.slice(0, previewCount.value);
});

// Êõ¥Êñ∞ÊêúÁ¥¢Êü•ËØ¢
async function handleSearch() {
  isRankedSearch.value = false;
  await questionStore.setSearchQuery(searchQuery.value, false);
}

// Êõ¥Êñ∞ÊòæÁ§∫Êï∞Èáè
function updateDisplayCount() {
  const countValue = parseInt(displayCount.value);
  const validCount = isNaN(countValue) ? 50 : Math.max(10, Math.min(100, countValue));
  questionStore.setTopQuestionCount(validCount);
}

// Êõ¥Êñ∞ËøáÊª§Âô®ÔºàÂÆûÊó∂È¢ÑËßàÔºâ
function updateFilter() {
  Object.values(filters).forEach(range => {
    if (parseFloat(range.min) > parseFloat(range.max)) {
      range.min = range.max;
    }
  });
}

// ÊâßË°åÊêúÁ¥¢ - ‰ΩøÁî®ÊéíÂ∫èÊ®°ÂºèÔºå‰ºòÂÖàÁ∫ßÊúÄÈ´ò
async function performSearch() {
  try {
    console.log('ÊâßË°åÊéíÂ∫èÊêúÁ¥¢Ê®°Âºè...');
    
    // 1. ËÆæÁΩÆÊú¨Âú∞Áä∂ÊÄÅÔºåÊòéÁ°ÆÊ†áËÆ∞‰∏∫ÊéíÂ∫èÊ®°Âºè
    isRankedSearch.value = true;
    
    // 2. ÂÖàÊ∏ÖÁ©∫Êú¨Âú∞ÊêúÁ¥¢ËæìÂÖ•Ê°ÜÁöÑÁõëÂê¨Âô®Ëß¶ÂèëÔºåÈò≤Ê≠¢Ê≠£Â∏∏ÊêúÁ¥¢ÈÄªËæëË¶ÜÁõñÊéíÂ∫èÈÄªËæë
    document.activeElement?.blur();
    
    // 3. ÂáÜÂ§áËØ∑Ê±ÇÊï∞ÊçÆ
    const requestData = {
      question: searchQuery.value,
      weights: {
        similarity_count: parseFloat((weights.relevance / 5).toFixed(4)),
        generation_reliability: parseFloat((weights.generation_reliability / 5).toFixed(4)),
        knowledge_reliability: parseFloat((weights.knowledge_reliability / 5).toFixed(4)),
        retrieval_effectiveness: parseFloat((weights.retrieval_effectiveness / 5).toFixed(4)),
        retrieval_stability: parseFloat((weights.retrieval_stability / 5).toFixed(4)),
        question_correctness: parseFloat((weights.correctness / 5).toFixed(4))
      }
    };
    
    console.log('ÂèëÈÄÅAPIËØ∑Ê±ÇÂà∞ÂêéÁ´Ø:', requestData);
    
    // 4. ÂèëÈÄÅËØ∑Ê±ÇÂà∞ÂêéÁ´ØAPI
    const response = await fetch('http://localhost:5000/api/weighted_rank', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(requestData),
    });
    
    if (!response.ok) {
      throw new Error(`APIËØ∑Ê±ÇÂ§±Ë¥•: ${response.status} ${response.statusText}`);
    }
    
    const data = await response.json();
    console.log('Êé•Êî∂Âà∞ÂêéÁ´ØÂìçÂ∫î:', data);
    
    if (!data.ranked_ids || !Array.isArray(data.ranked_ids)) {
      throw new Error('ÂêéÁ´ØÂìçÂ∫îÊ†ºÂºèÈîôËØØÔºåÁº∫Â∞ëranked_idsÊï∞ÁªÑ');
    }
    
    console.log('APIËøîÂõûÁöÑranked_idsÊï∞Èáè:', data.ranked_ids.length, 'Ââç5‰∏™:', data.ranked_ids.slice(0, 5));
    
    // 5. ÈáçÁΩÆquestionStoreÁöÑÁä∂ÊÄÅÔºåÁ°Æ‰øù‰ΩøÁî®Êñ∞ÁöÑÊéíÂ∫è
    questionStore.useRankedSearch = true;  // ÊòéÁ°ÆËÆæÁΩÆ‰∏∫true
    questionStore.rankedIds = data.ranked_ids;
    
    // ÈáçÁΩÆÊâÄÊúâËøáÊª§Êù°‰ª∂‰ª•Ëé∑ÂæóÂÆåÊï¥ÂéüÂßãÊéíÂ∫èÊïàÊûú
    console.log('ÈáçÁΩÆÊâÄÊúâËøáÊª§Êù°‰ª∂‰ª•Á°Æ‰øùÁ∫ØÁ≤πÁöÑÊéíÂ∫èÊïàÊûú');
    questionStore.filterConditions = {
      retrieval_effectiveness: { min: 0, max: 1 },
      retrieval_stability: { min: 0, max: 1 },
      generation_reliability: { min: 0, max: 1 },
      knowledge_reliability: { min: 0, max: 1 }
    };
    
    // 6. Á°Æ‰øùËß£Èô§ÂèØËÉΩÁöÑÈòªÂ°û
    questionStore.isUpdatingFilters = false;
    
    // 7. Âº∫Âà∂Âà∑Êñ∞Áä∂ÊÄÅ - Áõ¥Êé•Ë∞ÉÁî®applyFilters
    console.log('Áõ¥Êé•Ë∞ÉÁî®applyFiltersÂº∫Âà∂Âà∑Êñ∞');
    await questionStore.applyFilters();
    
    // 8. È™åËØÅrankedIdsÊòØÂê¶Ê≠£Á°ÆÂ∫îÁî®
    const firstFiveFiltered = questionStore.filteredQuestions.slice(0, 5).map(q => q.id);
    const firstFiveRanked = data.ranked_ids.slice(0, 5);
    console.log('ÊéíÂ∫èÊêúÁ¥¢ÊâßË°åÁªìÊûúÂØπÊØî:');
    console.log('- APIËøîÂõûÁöÑÂâç5‰∏™ID:', firstFiveRanked);
    console.log('- ËøáÊª§ÂêéÁöÑÂâç5‰∏™ID:', firstFiveFiltered);
    console.log('- ÊòØÂê¶ÂåπÈÖç:', JSON.stringify(firstFiveFiltered) === JSON.stringify(firstFiveRanked));
    
    // Â¶ÇÊûú‰∏çÂåπÈÖçÔºåÂ∞ùËØïÂº∫Âà∂ÂÜçÊ¨°Â∫îÁî®
    if (JSON.stringify(firstFiveFiltered) !== JSON.stringify(firstFiveRanked)) {
      console.log('ÊéíÂ∫èÊú™Ê≠£Á°ÆÂ∫îÁî®ÔºåÂÜçÊ¨°Â∞ùËØï...');
      // Áõ¥Êé•‰øÆÊîπfilteredQuestionsÔºåÊåâÁÖßranked_idsÁöÑÈ°∫Â∫èÈáçÊñ∞ÊéíÂàó
      const orderedQuestions = [];
      
      for (const id of data.ranked_ids) {
        const numericId = typeof id === 'string' ? parseInt(id) : id;
        let question = questionStore.allQuestions.find(q => {
          const qId = q.id;
          const numericQId = typeof qId === 'string' ? parseInt(qId) : qId;
          return numericId === numericQId || numericId === qId || 
                (typeof numericId === 'number' && numericId.toString() === qId);
        });
        
        if (question) {
          orderedQuestions.push(question);
        }
      }
      
      // ÂèñÂâçN‰∏™ÈóÆÈ¢òÂπ∂Áõ¥Êé•Êõ¥Êñ∞
      const displayCount = Math.min(orderedQuestions.length, questionStore.topQuestionCount);
      questionStore.filteredQuestions = orderedQuestions.slice(0, displayCount);
      
      console.log('Âº∫Âà∂ÊéíÂ∫èÂêéÁöÑÂâç5‰∏™ÈóÆÈ¢òID:', 
        questionStore.filteredQuestions.slice(0, 5).map(q => q.id));
    }
  } catch (error) {
    console.error('ÊéíÂ∫èÊêúÁ¥¢Âá∫Èîô:', error);
    alert('ÊêúÁ¥¢ËØ∑Ê±ÇÂ§±Ë¥•: ' + error.message);
  }
}

// Âú®ÁÉ≠Âõæ‰∏≠ÊòæÁ§∫ - ‰ΩøÁî®ÊôÆÈÄöÊêúÁ¥¢Ê®°Âºè
function showInHeatmap() {
  if (!searchQuery.value.trim()) return;
  
  // ÊôÆÈÄöÊêúÁ¥¢Ê®°Âºè - ÊòéÁ°ÆÊåáÂÆö‰∏ç‰ΩøÁî®ÊéíÂ∫èÊï∞ÊçÆ
  isRankedSearch.value = false;
  
  // Á°Æ‰øùÊôÆÈÄöÊêúÁ¥¢Ê®°Âºè‰∏ç‰ºöË¢´ÊÑèÂ§ñË¶ÜÁõñ
  questionStore.setSearchQuery(searchQuery.value, false);
  
  // ‰ΩøÁî®ÊôÆÈÄöÊêúÁ¥¢Ê®°ÂºèÁöÑ‰∫ã‰ª∂
  eventBus.emit('showSearchInHeatmap', {
    query: searchQuery.value,
    position: 'center',
    useRanking: false, // ÊòéÁ°ÆÊåáÂÆö‰∏ç‰ΩøÁî®ÊéíÂ∫èÊï∞ÊçÆ
    timestamp: Date.now() // Ê∑ªÂä†Êó∂Èó¥Êà≥Á°Æ‰øù‰∫ã‰ª∂ÂîØ‰∏ÄÊÄß
  });
}

// Ê∑ªÂä†Ê†áÁ≠æ
function addTag(tag) {
  if (tag && tag.trim()) {
    customTags.value.push(tag.trim());
    newTag.value = '';
  }
}

// ÁßªÈô§Ê†áÁ≠æ
function removeTag(index) {
  customTags.value.splice(index, 1);
}

// Â∫îÁî®ËøáÊª§Âô®
async function applyChanges() {
  await nextTick();
  await questionStore.setFilterConditions(filters);
  
  Object.assign(filtersBackup, JSON.parse(JSON.stringify(filters)));
  Object.assign(weightsBackup, JSON.parse(JSON.stringify(weights)));
  tagsBackup.value = [...customTags.value];
}

// ÁßªÈô§ÁâπÂÆöËøáÊª§Âô®
async function removeFilter(key) {
  if (key && filters[key]) {
    filters[key].min = 0;
    filters[key].max = 1;
    await questionStore.setFilterConditions(filters);
  }
}

// Ê∏ÖÈô§ÊâÄÊúâËøáÊª§Âô®ÂíåÊ†áÁ≠æ
async function clearAllFilters() {
  await questionStore.resetFilters();
  searchQuery.value = '';
  customTags.value = [];
}

// ÈÄâÊã©ÈóÆÈ¢ò
async function selectQuestion(question) {
  // ‰ºòÂÖà‰ªéresult8.json‰∏≠Ëé∑ÂèñÂÆåÊï¥Êï∞ÊçÆ
  try {
    // Âä†ËΩΩÈóÆÈ¢òÊï∞ÊçÆ
    const dataModule = await import('../../statics/result8.json');
    const result8Data = dataModule.default || [];
    
    // Áõ¥Êé•‰ΩøÁî®id-1‰Ωú‰∏∫Á¥¢ÂºïËé∑ÂèñÈóÆÈ¢ò
    const id = parseInt(question.id);
    const completeQuestion = result8Data[id-1];
    
    console.log('‰ªéresult8Ëé∑ÂèñÁöÑÈóÆÈ¢ò(index:', id-1, '):', completeQuestion);
    console.log('gtÂ≠óÊÆµ:', completeQuestion.gt);
    console.log('answerÂ≠óÊÆµ:', completeQuestion.answer);
    
    // ‰ΩøÁî®ÂÆåÊï¥ÈóÆÈ¢òÊï∞ÊçÆÊõ¥Êñ∞store
    if (completeQuestion) {
      questionStore.setQuestion(completeQuestion, question.id);
    } else {
      // Â¶ÇÊûúÂú®result8‰∏≠Êâæ‰∏çÂà∞ÔºåÂÜç‰ΩøÁî®‰º†ÂÖ•ÁöÑÈóÆÈ¢ò
      questionStore.setQuestion(question, question.id);
    }
  } catch (error) {
    console.error('‰ªéresult8Âä†ËΩΩÈóÆÈ¢òÊï∞ÊçÆÂ§±Ë¥•:', error);
    // Âá∫ÈîôÊó∂‰ΩøÁî®‰º†ÂÖ•ÁöÑÈóÆÈ¢ò
    questionStore.setQuestion(question, question.id);
  }
  
  // ‰ΩøÁî®pointSelected‰∫ã‰ª∂ÈÄöÁü•ÁÉ≠ÂäõÂõæ
  const eventData = {
    id: question.id,
    isFromFilterView: true
  };
  
  eventBus.emit('pointSelected', eventData);
}

// Êà™Êñ≠ÊñáÊú¨
function truncateText(text, maxLength) {
  if (!text) return '';
  if (text.length <= maxLength) return text;
  return text.substring(0, maxLength) + '...';
}

// ËÆ°ÁÆóÊòØÂê¶ÊúâÊ¥ªÂä®ËøáÊª§Âô®
const hasActiveFiltersOrTags = computed(() => {
  return activeFilters.value.length > 0 || customTags.value.length > 0;
});

// Ê¥ªÂä®ËøáÊª§Âô®ÂàóË°®
const activeFilters = computed(() => {
  const result = [];
  
  const filterNames = {
    retrieval_effectiveness: 'Retrieval Failure',
    retrieval_stability: 'Prompt Fragility',
    generation_reliability: 'Generation Anomaly',
    knowledge_reliability: 'Standard Deviation'
  };
  
  Object.entries(filters).forEach(([key, value]) => {
    if (value.min > 0) {
      result.push({
        key,
        label: `${filterNames[key]} Min`,
        value: `${Math.round(value.min * 100)}%`
      });
    }
    
    if (value.max < 1) {
      result.push({
        key,
        label: `${filterNames[key]} Max`,
        value: `${Math.round(value.max * 100)}%`
      });
    }
  });
  
  return result;
});

// Ê∑ªÂä†Êñ∞ÈóÆÈ¢òÂ§ÑÁêÜÂáΩÊï∞
const handleAddQuestion = () => {
  const query = searchQuery.value.trim();
  if (query) {
    questionStore.addNewQuestion(query);
    // ÂèØÈÄâÔºöÊ∑ªÂä†ÂêéÊ∏ÖÁ©∫ÊêúÁ¥¢Ê°Ü
    // searchQuery.value = ''; 
  } else {
    console.warn("Search query is empty, cannot add question.");
    // ËøôÈáåÂèØ‰ª•Ê∑ªÂä†‰∏Ä‰∫õÁî®Êà∑ÊèêÁ§∫Ôºå‰æãÂ¶ÇÂºπÂá∫‰∏Ä‰∏™Â∞èÁöÑÊèêÁ§∫‰ø°ÊÅØ
  }
};
</script>

<style scoped>
.filter-view {
  display: flex;
  flex-direction: column;
  gap: 8px;
  height: 100%;
  width: 100%; /* Ensure using full width */
  background-color: white;
  border-radius: 8px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  padding: 12px;
  overflow: hidden;
  font-family: 'Lato', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
}

/* Compact control area styles */
.control-section {
  display: flex;
  flex-direction: column;
  gap: 6px;
  margin-bottom: 6px;
}

.main-controls {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.search-section {
  display: flex;
  align-items: center;
  flex: 1;
  margin-right: 6px;
}

.search-box {
  flex: 1;
  padding: 4px 8px;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 16px;
  height: 30px;
  font-family: 'Lato', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
}

.filter-btn, .search-btn, .confirm-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 30px;
  height: 30px;
  border: 1px solid #ddd;
  border-radius: 4px;
  background-color: #f9f9f9;
  margin-left: 4px;
  cursor: pointer;
}

.filter-icon, .search-icon, .confirm-icon {
  font-style: normal;
  font-size: 16px;
}

.confirm-btn {
  background-color: #e3f2fd;
  border-color: #bbdefb;
}

.confirm-icon {
  color: #2196f3;
}

.slider-container {
  display: flex;
  align-items: center;
  white-space: nowrap;
}

.slider-label {
  font-size: 16px;
  color: #555;
  margin-right: 4px;
}

.density-slider {
  width: 80px;
  margin: 0 4px;
  height: 4px;
  accent-color: #4d7fa0;
}

.slider-value {
  font-size: 16px;
  color: #555;
  min-width: 20px;
}

/* Compact filter tags styles */
.active-filters {
  padding: 4px;
  background-color: #f7f9fa;
  border-radius: 4px;
}

.filter-chips {
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
  align-items: center;
}

.filter-chip, .tag-chip {
  display: flex;
  align-items: center;
  border-radius: 10px;
  padding: 2px 8px;
  font-size: 16px;
  height: 24px;
}

.filter-chip {
  background-color: #e0e0e0;
}

.tag-chip {
  background-color: #e3f2fd;
  border: 1px solid #bbdefb;
}

.remove-filter, .remove-tag {
  background: none;
  border: none;
  font-size: 16px;
  cursor: pointer;
  margin-left: 2px;
  padding: 0 2px;
  line-height: 1;
}

.remove-tag {
  color: #2196f3;
}

.tag-icon {
  margin-right: 2px;
  font-size: 14px;
}

.clear-all {
  background: none;
  border: none;
  color: #3498db;
  cursor: pointer;
  font-size: 16px;
  padding: 1px 4px;
  height: 24px;
}

/* Question preview area styles */
.question-preview {
  border-top: 1px solid #f0f0f0;
  padding-top: 4px;
  width: 100%; /* Ensure using full width */
  flex: 1; /* ÂÖÅËÆ∏È¢ÑËßàÂå∫ÂüüÁÅµÊ¥ªÂèòÂåñÈ´òÂ∫¶ */
  min-height: 120px; /* ÊúÄÂ∞èÈ´òÂ∫¶ */
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.section-title {
  margin: 0 0 4px 0;
  font-size: 16px;
  color: #333;
}

.preview-list {
  font-size: 16px;
  flex: 1; /* ‰ΩøÂàóË°®Â°´ÂÖÖÂâ©‰ΩôÁ©∫Èó¥ */
  overflow-y: auto;
  scrollbar-width: none; /* Firefox */
  -ms-overflow-style: none; /* IE and Edge */
  overflow-x: hidden;
  width: 100%; /* Ensure using full width */
}

.preview-list::-webkit-scrollbar {
  display: none; /* Chrome, Safari, Opera */
}

.preview-item {
  padding: 4px 6px;
  font-size: 16px;
  border-radius: 3px;
  margin-bottom: 2px;
  cursor: pointer;
  display: flex;
  align-items: flex-start;
  line-height: 1.2;
}

.preview-item:hover {
  background-color: #f5f5f5;
}

.preview-item.highlighted {
  background-color: #e3f2fd;
}

.item-id {
  color: #888;
  margin-right: 8px;
  font-size: 16px;
  flex-shrink: 0;
}

.item-text {
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
}

.more-items {
  text-align: center;
  color: #888;
  font-size: 16px;
  padding: 4px;
  font-style: italic;
}

.empty-preview {
  color: #888;
  text-align: center;
  padding: 20px;
  font-style: italic;
  font-size: 16px;
}

/* Inline filter section */
.inline-filter-section {
  border-top: 1px solid #f0f0f0;
  margin-top: 6px;
  padding-top: 4px;
  width: 100%;
  flex-shrink: 0; /* Èò≤Ê≠¢ËøôÈÉ®ÂàÜË¢´ÂéãÁº© */
  display: flex;
  flex-direction: column;
}

.filter-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 6px;
}

.filter-header h3 {
  margin: 0;
  font-size: 16px;
  color: #333;
}

.filter-options {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.subsection-title {
  margin: 0 0 6px 0;
  font-size: 16px;
  color: #555;
  font-weight: normal;
}

/* Weight settings section */
.weights-section {
  background-color: #f9f9fa;
  padding: 8px;
  border-radius: 4px;
  margin-bottom: 6px; /* Ê∑ªÂä†‰∏ãËæπË∑ù */
}

.weights-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 6px; /* ÂáèÂ∞èÈó¥Ë∑ù */
}

.weight-item {
  display: flex;
  flex-direction: column;
}

.weight-label {
  font-size: 16px;
  margin-bottom: 2px; /* ÂáèÂ∞è‰∏ãËæπË∑ù */
}

.weight-control {
  display: flex;
  align-items: center;
}

.weight-slider {
  flex: 1;
  height: 4px;
  accent-color: #4d7fa0;
}

.weight-value {
  margin-left: 6px;
  font-size: 16px;
  color: #555;
  width: 18px;
  text-align: center;
}

/* Tag management section */
.tags-section {
  background-color: #f9f9fa;
  padding: 8px;
  border-radius: 4px;
}

.tags-input-container {
  display: flex;
  margin-bottom: 8px;
}

.tag-input {
  flex: 1;
  padding: 4px 8px;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 16px;
  font-family: 'Lato', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
}

.add-tag-btn {
  padding: 4px 8px;
  background-color: #3498db;
  color: white;
  border: none;
  border-radius: 4px;
  margin-left: 4px;
  font-size: 16px;
  cursor: pointer;
}

.tags-list {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  max-height: 60px; /* ÂáèÂ∞èÊ†áÁ≠æÂàóË°®ÁöÑÊúÄÂ§ßÈ´òÂ∫¶ */
  overflow-y: auto;
}

.tag-item {
  background-color: #e3f2fd;
  border-radius: 10px;
  padding: 2px 8px;
  font-size: 16px;
  display: flex;
  align-items: center;
}

.tag-name {
  margin-right: 4px;
}

.remove-tag-btn {
  background: none;
  border: none;
  color: #3498db;
  cursor: pointer;
  font-size: 16px;
  line-height: 1;
  padding: 0;
}

.no-tags {
  color: #999;
  font-style: italic;
  text-align: center;
  width: 100%;
  padding: 8px;
  font-size: 16px;
}

/* Bottom buttons */
.filter-footer {
  display: flex;
  justify-content: flex-end;
  gap: 8px;
  margin-top: 6px;
}

.apply-btn {
  padding: 6px 12px;
  border-radius: 4px;
  font-size: 16px;
  cursor: pointer;
  background-color: #3498db;
  border: none;
  color: white;
}
</style>